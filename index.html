<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Heap Sort Visualizer (C++ Code)</title>
<style>
:root{
  --bg:#fffaf6; --card:#fff; --muted:#8a8a8a;
  --accent:#9ad1c7; --accent-2:#f7c6d7;
  --node-bg:#fff; --node-border:#d6dbe3;
  --shadow:0 6px 18px rgba(46,49,55,0.06);
}
*{box-sizing:border-box;}
body{margin:0;font-family:Inter,sans-serif;background:var(--bg);color:#243142;padding:20px;}
header{display:flex;align-items:center;gap:16px;margin-bottom:18px;}
h1{margin:0;font-size:20px}
.sub{color:var(--muted);font-size:13px}
.app{display:grid;grid-template-columns:420px 1fr 360px;gap:18px;align-items:start;}
.card{background:var(--card);border-radius:14px;padding:14px;box-shadow:var(--shadow);}
.controls .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
label{font-size:13px;color:var(--muted);min-width:110px}
input[type="text"]{flex:1;padding:8px 10px;border-radius:10px;border:1px solid var(--node-border);background:#fff;font-family:monospace;}
button{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:0;padding:8px 12px;border-radius:10px;color:#102226;cursor:pointer;font-weight:600;}
.muted-btn{background:transparent;border:1px dashed var(--node-border);color:var(--muted);padding:8px 10px;}
.toggles{display:flex;gap:8px;}
.visual.card{padding:12px;height:640px;display:flex;flex-direction:column}
.tree-wrap{flex:1;position:relative;border-radius:12px;background:linear-gradient(180deg,#fff,#fffafc);overflow:hidden;padding:18px;}
.node{position:absolute;transform:translate(-50%,-50%);min-width:44px;padding:10px 12px;border-radius:999px;background:var(--node-bg);border:2px solid var(--node-border);box-shadow:0 6px 18px rgba(36,49,66,0.06);text-align:center;font-weight:700;transition:box-shadow .18s,transform .18s;will-change:transform;}
.node.compare{box-shadow:0 10px 26px rgba(247,198,215,0.22);border-color:#f7c6d7;transform:scale(1.06)}
.node.swap{box-shadow:0 10px 26px rgba(154,209,199,0.22);border-color:#9ad1c7;transform:scale(1.08)}
.node.sorted{background:linear-gradient(90deg,#e7ffe6,#fff);border-color:#c6edce;color:#27663e}
.steps{font-family:monospace;background:#fbfbfb;padding:8px;border-radius:8px;border:1px solid var(--node-border);height:120px;overflow:auto}
.code-panel{background:#fffafa;border-radius:8px;padding:10px;border:1px solid var(--node-border);font-family:monospace;font-size:13px;height:640px;overflow:auto;}
.code-line{padding:1px 4px;}
footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
@media (max-width:1200px){.app{grid-template-columns:1fr; padding-bottom:60px}.visual{order:2}}
</style>
</head>
<body>
<header>
  <div>
    <h1>Heap Sort Visualizer (C++ Code)</h1>
    <div class="sub">Pastel theme • Bezier animation • Max / Min live toggle</div>
  </div>
</header>

<div class="app">
  <!-- left controls -->
  <div class="card controls">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-weight:700">Controls</div>
    </div>
    <div class="row">
      <label>Nhập mảng (dấu ,)</label>
      <input id="arrInput" type="text" value="4,10,3,5,1" />
    </div>
    <div class="row">
      <label></label>
      <div style="display:flex;gap:8px">
        <button id="setBtn">Set array</button>
        <button id="randomBtn" class="muted-btn">Random</button>
        <button id="shuffleBtn" class="muted-btn">Shuffle</button>
      </div>
    </div>
    <div class="row">
      <label>Heap Mode</label>
      <div class="toggles">
        <button id="modeBtn">Max-Heap</button>
      </div>
    </div>
    <div class="row">
      <label>Playback</label>
      <div style="display:flex;gap:8px">
        <button id="playBtn">▶ Play</button>
        <button id="stepBack">◀ Step</button>
        <button id="stepFwd">Step ▶</button>
        <button id="resetBtn" class="muted-btn">Reset</button>
      </div>
    </div>
  </div>

  <!-- center tree -->
  <div class="visual card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
      <div style="font-weight:700">Cây Heap</div>
    </div>
    <div id="treeWrap" class="tree-wrap">
      <svg id="paths" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none"></svg>
    </div>
    <div class="steps" id="stepInfo">Ready</div>
  </div>

  <!-- right code panel -->
  <div class="card code-panel" id="codePanel"></div>
</div>

<footer>Nhấn "Play" để chạy tự động — animation sử dụng đường cong Bezier.</footer>

<script>
const treeWrap = document.getElementById('treeWrap');
const pathsSvg = document.getElementById('paths');
const arrInput = document.getElementById('arrInput');
const setBtn = document.getElementById('setBtn');
const randomBtn = document.getElementById('randomBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const modeBtn = document.getElementById('modeBtn');
const playBtn = document.getElementById('playBtn');
const stepBack = document.getElementById('stepBack');
const stepFwd = document.getElementById('stepFwd');
const resetBtn = document.getElementById('resetBtn');
const stepInfo = document.getElementById('stepInfo');
const codePanel = document.getElementById('codePanel');

let ARRAY=[4,10,3,5,1], NODE_MAP={}, steps=[], currentStep=0, playing=false, isMax=true, animating=false, animationDuration=600;

const HEAP_SORT_CODE=[
'#include < bits/stdc++.h >',
'using namespace std;',
'',
'void heapify(vector< int > & arr, int n, int i, bool isMax){',
'    int extreme = i;',
'    int l = 2*i + 1, r = 2*i + 2;',
'    if(l < n && ((isMax && arr[l] > arr[extreme]) || (!isMax && arr[l] < arr[extreme])))',
'        extreme = l;',
'    if(r < n && ((isMax && arr[r] > arr[extreme]) || (!isMax && arr[r] < arr[extreme])))',
'        extreme = r;',
'    if(extreme != i){',
'        swap(arr[i], arr[extreme]);',
'        heapify(arr, n, extreme, isMax);',
'    }',
'}',
'',
'void heapSort(vector< int >& arr, bool isMax=true){',
'    int n = arr.size();',
'    for(int i = n/2 - 1; i >= 0; i--)',
'        heapify(arr, n, i, isMax);',
'    for(int i = n-1; i > 0; i--){',
'        swap(arr[0], arr[i]);',
'        heapify(arr, i, 0, isMax);',
'    }',
'}',
'',
'int main(){',
'    vector< int > arr = {4,10,3,5,1};',
'    heapSort(arr);',
'    for(int v : arr) cout << v << " ";',
'    return 0;',
'}'
];

// render code panel
codePanel.innerHTML = HEAP_SORT_CODE.map((line,i)=>`<div class="code-line" id="code-line-${i}">${line}</div>`).join('');

// helpers
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function sleep(ms){return new Promise(r=>setTimeout(r,ms))}
function parseInput(str){return str.split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number).filter(n=>!Number.isNaN(n));}
function randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
function randomArray(len=7,maxVal=99){return Array.from({length:len},()=>randInt(1,maxVal));}
function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

// tree layout
function computePositions(arr){
  const width=treeWrap.clientWidth,height=treeWrap.clientHeight;
  const levels=Math.floor(Math.log2(arr.length))+1;
  const positions={};
  for(let i=0;i<arr.length;i++){
    const level=Math.floor(Math.log2(i+1)),levelStart=Math.pow(2,level)-1,indexInLevel=i-levelStart,nodesInLevel=Math.pow(2,level);
    const padding=30,availW=width-padding*2;
    const x=padding+(indexInLevel+0.5)*(availW/nodesInLevel);
    const y=30+level*((height-60)/levels);
    positions[i]={x,y};
  }
  return positions;
}
function clearNodes(){NODE_MAP={};pathsSvg.innerHTML='';treeWrap.querySelectorAll('.node').forEach(n=>n.remove());}
function renderTree(arr){
  clearNodes();
  const pos=computePositions(arr);
  for(let i=0;i<arr.length;i++){
    const left=2*i+1,right=2*i+2;
    if(left<arr.length)addCurvePath(pos[i],pos[left]);
    if(right<arr.length)addCurvePath(pos[i],pos[right]);
  }
  for(let i=0;i<arr.length;i++){
    const div=document.createElement('div'); div.className='node'; div.dataset.index=i; div.textContent=arr[i];
    div.style.left=pos[i].x+'px'; div.style.top=pos[i].y+'px';
    treeWrap.appendChild(div); NODE_MAP[i]=div;
  }
}

// SVG Bezier edge
function addCurvePath(p1,p2){
  const dx=p2.x-p1.x,dy=p2.y-p1.y,c1x=p1.x+dx*0.2,c1y=p1.y+30,c2x=p1.x+dx*0.8,c2y=p2.y-20;
  const path=document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d',`M ${p1.x} ${p1.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`);
  path.setAttribute('fill','none'); path.setAttribute('stroke','rgba(200,204,210,0.7)'); path.setAttribute('stroke-width','2');
  pathsSvg.appendChild(path);
}

// steps recording
function recordStep(desc,arrSnapshot,highlight){steps.push({desc,arr:[...arrSnapshot],highlight});}
function clearSteps(){steps=[];currentStep=0;}

// heap sort
function compareFunc(a,b){return isMax?a>b:a<b;}
function heapSortWithSteps(arr){
  clearSteps(); let a=[...arr]; const n=a.length;
  function heapify(nLocal,i){
    let extreme=i,left=2*i+1,right=2*i+2;
    if(left<nLocal)recordStep(`So sánh idx ${i} với con trái idx ${left}`,a,{type:'compare',indices:[i,left]});
    if(right<nLocal)recordStep(`So sánh idx ${i} với con phải idx ${right}`,a,{type:'compare',indices:[i,right]});
    if(left<nLocal && compareFunc(a[left],a[extreme])) extreme=left;
    if(right<nLocal && compareFunc(a[right],a[extreme])) extreme=right;
    if(extreme!=i){
      recordStep(`Hoán đổi idx ${i} và idx ${extreme}`,a,{type:'swap',indices:[i,extreme]});
      [a[i],a[extreme]]=[a[extreme],a[i]];
      heapify(nLocal,extreme);
    } else recordStep(`Không cần hoán đổi idx ${i}`,a,{type:'none',indices:[i]});
  }
  for(let i=Math.floor(n/2)-1;i>=0;i--){recordStep(`Heapify idx ${i}`,a,{type:'call',indices:[i]});heapify(n,i);}
  recordStep('Max/Min-heap xong',a,{type:'info',indices:[]});
  for(let i=n-1;i>0;i--){
    recordStep(`Swap root idx 0 và idx ${i}`,a,{type:'swap',indices:[0,i]});
    [a[0],a[i]]=[a[i],a[0]];
    recordStep(`Idx ${i} sorted`,a,{type:'sorted',indices:[i]});
    heapify(i,0);
  }
  recordStep('Hoàn tất',a,{type:'done',indices:[]});
}

// highlight nodes
function highlightIndices(type,indices){
  Object.values(NODE_MAP).forEach(n=>n.classList.remove('compare','swap','sorted'));
  if(!indices) return; indices.forEach(i=>{const n=NODE_MAP[i];if(!n)return;if(type==='compare')n.classList.add('compare');if(type==='swap')n.classList.add('swap');if(type==='sorted')n.classList.add('sorted');});
}

// highlight code lines
function getCodeLineForStep(type,indices){
  switch(type){case 'compare':return 8;case 'swap':return 12;case 'sorted':return 18;case 'call':return 6;default:return -1;}
}
function highlightCode(type,indices){HEAP_SORT_CODE.forEach((_,i)=>{const el=document.getElementById(`code-line-${i}`);if(el)el.style.background='none';}); const line=getCodeLineForStep(type,indices); if(line>=0){const el=document.getElementById(`code-line-${line}`);if(el)el.style.background='rgba(255,230,180,0.5)';}}

// animate swap nodes
function animateSwap(i,j,targetArr){return new Promise(async resolve=>{
  animating=true;
  const pos=computePositions(targetArr),nodeA=NODE_MAP[i],nodeB=NODE_MAP[j];
  const pA={x:parseFloat(nodeA.style.left),y:parseFloat(nodeA.style.top)};
  const pB={x:parseFloat(nodeB.style.left),y:parseFloat(nodeB.style.top)};
  const cloneA=nodeA.cloneNode(true),cloneB=nodeB.cloneNode(true);
  cloneA.style.left=pA.x+'px'; cloneA.style.top=pA.y+'px'; cloneB.style.left=pB.x+'px'; cloneB.style.top=pB.y+'px';
  cloneA.classList.add('swap'); cloneB.classList.add('swap'); nodeA.style.opacity='0.2'; nodeB.style.opacity='0.2';
  treeWrap.appendChild(cloneA); treeWrap.appendChild(cloneB);
  const pTargetA=pos[j],pTargetB=pos[i]; const start=performance.now();
  function tick(now){const t=clamp((now-start)/animationDuration,0,1); const ease=t*(2-t);
    cloneA.style.left=pA.x+(pTargetA.x-pA.x)*ease+'px'; cloneA.style.top=pA.y+(pTargetA.y-pA.y)*ease+'px';
    cloneB.style.left=pB.x+(pTargetB.x-pB.x)*ease+'px'; cloneB.style.top=pB.y+(pTargetB.y-pB.y)*ease+'px';
    if(t<1) requestAnimationFrame(tick); else{cloneA.remove();cloneB.remove();
      [NODE_MAP[i].textContent,NODE_MAP[j].textContent]=[NODE_MAP[j].textContent,NODE_MAP[i].textContent];
      nodeA.style.opacity='1';nodeB.style.opacity='1';animating=false;resolve();}}
  requestAnimationFrame(tick);
});}

// render step
async function renderStep(idx){const st=steps[idx];if(!st)return;
  stepInfo.textContent=`Step ${idx+1}/${steps.length}: ${st.desc}`;
  highlightCode(st.highlight?.type||'none',st.highlight?.indices||[]);
  highlightIndices(st.highlight?.type||'none',st.highlight?.indices||[]);
  if(st.highlight?.type==='swap'){const [i,j]=st.highlight.indices; await animateSwap(i,j,st.arr);} else renderTree(st.arr);
}

// play steps
async function playSteps(){playing=true; while(currentStep<steps.length && playing){if(animating)await sleep(50);await renderStep(currentStep);currentStep++; await sleep(250);} playing=false;}

// init
function init(){ARRAY=[...parseInput(arrInput.value)];renderTree(ARRAY);heapSortWithSteps(ARRAY);currentStep=0;}
setBtn.onclick=()=>{init();}; randomBtn.onclick=()=>{ARRAY=randomArray(randInt(5,9));arrInput.value=ARRAY.join(',');init();};
shuffleBtn.onclick=()=>{shuffle(ARRAY);arrInput.value=ARRAY.join(',');init();};
modeBtn.onclick=()=>{isMax=!isMax;modeBtn.textContent=isMax?'Max-Heap':'Min-Heap';init();};
playBtn.onclick=()=>{if(!playing)playSteps();};
stepFwd.onclick=async()=>{if(currentStep<steps.length)await renderStep(currentStep++);}
stepBack.onclick=async()=>{if(currentStep>0)await renderStep(--currentStep);}
resetBtn.onclick=()=>{currentStep=0;renderTree(ARRAY);stepInfo.textContent='Reset';};
init();
</script>
</body>
</html>
